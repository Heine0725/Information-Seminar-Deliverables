<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ロボットシミュレーション</title>
  <style>
    body {
      margin:0;
      font-family: sans-serif;
      background:#fafafa;
      position: relative;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      border:1px solid #aaa;
      touch-action:none;
      display:block;
      margin:0 auto;
    }

    #controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background:#eee;
      padding:10px;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }

    label { margin-right:10px; }

    #credit {
      position: absolute;
      bottom: 0;
      right: 10px;
      font-size:14px;
      color: #333;
      padding: 5px 0;
    }

    #credit a { color:blue; text-decoration:none; }
  </style>
</head>
<body>

  <canvas id="canvas" width="800" height="600"></canvas>

  <div id="controls">
    <label>速度: <input type="range" id="speedSlider" min="0.5" max="10" step="0.5" value="3"></label>
    <label>太さ: <input type="range" id="thicknessSlider" min="1" max="10" step="1" value="3"></label>
    <label>壁判定閾値: <input type="range" id="wallSlider" min="0" max="255" step="5" value="50"></label>
    <button id="startBtn">スタート</button>
    <button id="resetBtn">リセット</button>
    <input type="file" id="bgPicker" accept="image/*">
    <button id="clearLineBtn">線を消す</button>
    <button id="clearBgBtn">背景を消す</button>
  </div>

  <div id="credit">
    作成者: <a href="https://kanata86gt.github.io/Information-Seminar-Deliverables/" target="_blank">風巻波稲</a>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let linePoints = [];
    let smoothPoints = [];
    let robotPos = null;
    let robotIndex = 0;
    let moving = false;
    let drawing = false;

    let speed = 3;
    let lineWidth = 3;
    let wallThreshold = 50;
    const robotRadius = 12;

    let bgImage = null;
    let bgCanvas = document.createElement("canvas");
    let bgCtx = bgCanvas.getContext("2d");

    // ---- UI ----
    document.getElementById("speedSlider").oninput = e => speed = parseFloat(e.target.value);
    document.getElementById("thicknessSlider").oninput = e => lineWidth = parseInt(e.target.value);
    document.getElementById("wallSlider").oninput = e => wallThreshold = parseInt(e.target.value);

    document.getElementById("startBtn").onclick = () => {
      if (!smoothPoints.length) { alert("線を描いてください"); return; }
      robotPos = [...smoothPoints[0]];
      robotIndex = 0;
      moving = true;
    };

    document.getElementById("resetBtn").onclick = () => {
      linePoints = [];
      smoothPoints = [];
      robotPos = null;
      robotIndex = 0;
      moving = false;
      draw();
    };

    document.getElementById("bgPicker").onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        bgCanvas.width = canvas.width;
        bgCanvas.height = canvas.height;
        bgCtx.drawImage(img, 0, 0, canvas.width, canvas.height);
        bgImage = img;
        draw();
      };
      img.src = URL.createObjectURL(file);
    };

    // ---- 線を消す ----
    document.getElementById("clearLineBtn").onclick = () => {
      linePoints = [];
      smoothPoints = [];
      robotPos = null;
      robotIndex = 0;
      moving = false;
      draw();
    };

    // ---- 背景を消す ----
    document.getElementById("clearBgBtn").onclick = () => {
      bgImage = null;
      bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
      draw();
    };

    // ---- 線描画（マウス+タッチ両対応）----
    function getPos(e) {
      if (e.touches) {
        return [e.touches[0].clientX - canvas.getBoundingClientRect().left,
                e.touches[0].clientY - canvas.getBoundingClientRect().top];
      } else {
        return [e.offsetX, e.offsetY];
      }
    }

    function startDraw(e) {
      e.preventDefault();
      drawing = true;
      linePoints = [getPos(e)];
      smoothPoints = [];
      robotPos = null;
      robotIndex = 0;
      moving = false;
      draw();
    }

    function moveDraw(e) {
      if (!drawing) return;
      const pos = getPos(e);
      const last = linePoints[linePoints.length-1];
      const dx = pos[0]-last[0], dy=pos[1]-last[1];
      if (Math.hypot(dx,dy) > 2) {
        linePoints.push(pos);
        draw();
      }
    }

    function endDraw(e) {
      if (!drawing) return;
      drawing = false;
      if (linePoints.length > 2) {
        smoothPoints = smoothLine(linePoints, 0.8);
        robotPos = [...smoothPoints[0]];
        robotIndex = 0;
        draw();
      }
    }

    canvas.addEventListener("mousedown", startDraw);
    canvas.addEventListener("mousemove", moveDraw);
    canvas.addEventListener("mouseup", endDraw);
    canvas.addEventListener("touchstart", startDraw);
    canvas.addEventListener("touchmove", moveDraw);
    canvas.addEventListener("touchend", endDraw);

    // ---- 線平滑化 ----
    function smoothLine(points, strength) {
      if (points.length < 3) return points.slice();
      let sm = [points[0]];
      for (let i=1;i<points.length-1;i++) {
        const x = points[i][0]*(1-strength) + 0.5*(points[i-1][0]+points[i+1][0])*strength;
        const y = points[i][1]*(1-strength) + 0.5*(points[i-1][1]+points[i+1][1])*strength;
        sm.push([x,y]);
      }
      sm.push(points[points.length-1]);
      return sm;
    }

    // ---- ロボット更新 ----
    function updateRobot() {
      if (!moving || !robotPos || !smoothPoints.length) return;
      if (robotIndex >= smoothPoints.length-1) { moving=false; return; }

      const nextPt = smoothPoints[robotIndex+1];
      const dx = nextPt[0]-robotPos[0], dy=nextPt[1]-robotPos[1];
      const dist = Math.hypot(dx,dy);
      let move = speed;

      if (dist <= move) {
        robotPos = [...nextPt];
        robotIndex++;
      } else {
        robotPos = [robotPos[0]+dx/dist*move, robotPos[1]+dy/dist*move];
      }

      // 壁判定
      if (bgImage) {
        const x = Math.floor(robotPos[0]);
        const y = Math.floor(robotPos[1]);
        const pixel = bgCtx.getImageData(x,y,1,1).data;
        const gray = (pixel[0]+pixel[1]+pixel[2])/3;
        if (gray < wallThreshold) { moving=false; }
      }
    }

    // ---- 描画 ----
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (bgImage) ctx.drawImage(bgImage,0,0,canvas.width,canvas.height);

      // 完了線
      if (smoothPoints.length > 1) {
        ctx.beginPath();
        ctx.moveTo(smoothPoints[0][0], smoothPoints[0][1]);
        for (let pt of smoothPoints) ctx.lineTo(pt[0],pt[1]);
        ctx.strokeStyle="blue";
        ctx.lineWidth=lineWidth;
        ctx.stroke();
      }

      // 描画中線
      if (linePoints.length > 1 && drawing) {
        ctx.beginPath();
        ctx.moveTo(linePoints[0][0], linePoints[0][1]);
        for (let pt of linePoints) ctx.lineTo(pt[0],pt[1]);
        ctx.strokeStyle="blue";
        ctx.lineWidth=lineWidth;
        ctx.stroke();
      }

      // ロボット
      if (robotPos) {
        ctx.beginPath();
        ctx.arc(robotPos[0],robotPos[1],robotRadius,0,Math.PI*2);
        ctx.fillStyle="red";
        ctx.fill();
      }
    }

    function loop() {
      updateRobot();
      draw();
      requestAnimationFrame(loop);
    }
    loop();
  </script>

</body>
</html>
