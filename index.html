<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>PathTrace Controller</title>
  <style>
    body { margin:0; font-family:sans-serif; text-align:center; background:#f0f0f0; }
    #canvas { border:1px solid black; touch-action:none; background:white; }
    #controls { margin:10px; }
    label { margin:0 10px; }
    #credit { margin-top:10px; font-size:14px; color:#444; }
  </style>
</head>
<body>
  <h2>PathTrace Controller</h2>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <label>速度:
      <input type="range" id="speed" min="1" max="10" step="1" value="3">
    </label>
    <label>線の太さ:
      <input type="range" id="thickness" min="1" max="10" step="1" value="3">
    </label>
    <label>壁判定の値:
      <input type="range" id="threshold" min="0" max="255" step="5" value="50">
    </label>
    <input type="file" id="bgLoader" accept="image/*">
    <button id="start">スタート</button>
    <button id="reset">リセット</button>
  </div>
  <div class="credit">
  © 2025 <a href="about.html">作成者: 風巻波稲</a>
</div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const socket = io();

    let drawing = false;
    let lastX, lastY;
    let path = [];
    let allLines = [];
    let robot = {x:50,y:50};
    let moving = false;
    let speed = 3;
    let lineWidth = 3;
    let threshold = 50;
    let bgImage = null;
    let bgData = null;

    // =============== 背景読み込み ===============
    document.getElementById("bgLoader").addEventListener("change", e=>{
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = ()=>{
        bgImage = img;
        ctx.drawImage(bgImage,0,0,canvas.width,canvas.height);
        // ピクセルデータ取得
        ctx.drawImage(bgImage,0,0,canvas.width,canvas.height);
        bgData = ctx.getImageData(0,0,canvas.width,canvas.height);
      };
      img.src = URL.createObjectURL(file);
    });

    // =============== PC用描画イベント ===============
    canvas.addEventListener("mousedown", e=>{
      drawing = true;
      lastX = e.offsetX; lastY = e.offsetY;
      path = [{x:lastX,y:lastY}];
    });
    canvas.addEventListener("mousemove", e=>{
      if (!drawing) return;
      drawAndSend(e.offsetX, e.offsetY);
    });
    canvas.addEventListener("mouseup", ()=> drawing=false);
    canvas.addEventListener("mouseleave", ()=> drawing=false);

    // =============== スマホ用描画イベント ===============
    canvas.addEventListener("touchstart", e=>{
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      drawing = true;
      lastX = t.clientX - rect.left;
      lastY = t.clientY - rect.top;
      path = [{x:lastX,y:lastY}];
    });
    canvas.addEventListener("touchmove", e=>{
      if (!drawing) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      drawAndSend(t.clientX - rect.left, t.clientY - rect.top);
    });
    canvas.addEventListener("touchend", ()=> drawing=false);
    canvas.addEventListener("touchcancel", ()=> drawing=false);

    // =============== 線描画と送信 ===============
    function drawAndSend(x,y){
      ctx.beginPath();
      ctx.moveTo(lastX,lastY);
      ctx.lineTo(x,y);
      ctx.strokeStyle="blue";
      ctx.lineWidth=lineWidth;
      ctx.stroke();

      socket.emit("drawLine",{x1:lastX,y1:lastY,x2:x,y2:y, w:lineWidth});
      lastX=x; lastY=y;
      path.push({x,y});
    }

    // =============== ロボット描画 ===============
    function drawRobot(){
      ctx.beginPath();
      ctx.arc(robot.x,robot.y,10,0,Math.PI*2);
      ctx.fillStyle="red";
      ctx.fill();
    }

    // =============== 壁判定 ===============
    function isWall(x,y){
      if(!bgData) return false;
      if(x<0||y<0||x>=canvas.width||y>=canvas.height) return true;
      const idx=(y*canvas.width+x)*4;
      const gray=(bgData.data[idx]+bgData.data[idx+1]+bgData.data[idx+2])/3;
      return gray<threshold;
    }

    // =============== アニメーション ===============
    function animate(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(bgImage) ctx.drawImage(bgImage,0,0,canvas.width,canvas.height);

      // 線再描画
      allLines.forEach(line=>{
        ctx.beginPath();
        ctx.moveTo(line[0].x,line[0].y);
        for(let i=1;i<line.length;i++){
          ctx.lineTo(line[i].x,line[i].y);
        }
        ctx.strokeStyle="blue";
        ctx.lineWidth=lineWidth;
        ctx.stroke();
      });

      // ロボット移動
      if(moving && path.length>0){
        let target=path[0];
        let dx=target.x-robot.x, dy=target.y-robot.y;
        let dist=Math.hypot(dx,dy);
        if(dist<speed){
          robot.x=target.x; robot.y=target.y;
          path.shift();
        }else{
          let nx=robot.x+dx/dist*speed;
          let ny=robot.y+dy/dist*speed;
          if(isWall(Math.round(nx),Math.round(ny))){
            moving=false;
          }else{
            robot.x=nx; robot.y=ny;
          }
        }
        socket.emit("moveRobot",robot);
      }
      drawRobot();
      requestAnimationFrame(animate);
    }
    animate();

    // =============== UI操作 ===============
    document.getElementById("start").onclick=()=>{
      if(path.length>0){
        allLines.push([...path]);
        moving=true;
      }
    };
    document.getElementById("reset").onclick=()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      allLines=[];
      path=[];
      robot={x:50,y:50};
      moving=false;
      bgImage=null; bgData=null;
      socket.emit("reset");
    };
    document.getElementById("speed").oninput=e=>{
      speed=parseInt(e.target.value);
    };
    document.getElementById("thickness").oninput=e=>{
      lineWidth=parseInt(e.target.value);
    };
    document.getElementById("threshold").oninput=e=>{
      threshold=parseInt(e.target.value);
    };

    // =============== サーバーイベント ===============
    socket.on("drawLine",d=>{
      ctx.beginPath();
      ctx.moveTo(d.x1,d.y1);
      ctx.lineTo(d.x2,d.y2);
      ctx.strokeStyle="blue";
      ctx.lineWidth=d.w;
      ctx.stroke();
    });
    socket.on("moveRobot",d=>{
      robot=d;
    });
    socket.on("reset",()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      allLines=[]; path=[]; robot={x:50,y:50};
      moving=false; bgImage=null; bgData=null;
    });
  </script>
</body>
</html>
